---
layout: post
title: 'Expressing What An API Does As Well As What Is Possible Using OpenAPI'
source: http://apievangelist.com/2017/05/01/expressing-what-an-api-does-as-well-as-what-is-possible-using-openapi/
domain: apievangelist.com
image: http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/openapi-spec.png
atomdate: 2017-05-01T15:00:00-07:00
---
<p><img style="padding: 15px;" src="http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/openapi-spec.png" alt="" width="30%" align="right" /></p>
<p>I am working to update <a href="http://apievangelist.com/2017/05/01/quantifying-the-api-landscape-across-amazon-google-and-microsoft/">my OpenAPI definitions for AWS, Google, and Microsoft</a> using some other OpenAPIs I've discovered on Github. When a new OpenAPI has entirely new paths available, I just insert them, but when it has an existing path I have to think more critically about what is next. Sometimes I dismiss the metadata about the API path as incomplete or lower quality than the one I have already. Other times the content is actually more superior than mine, and I incorporate it into my work. Now I'm also finding that in some cases I want to keep my representation, as well as the one I discovered, side by side--both having value.</p>
<p>This is one reason I'm not 100% sold on the fact that just API providers should be crafting their own OpenAPis--sure, the API space would be waaaaaay better if <span style="text-decoration: underline;">ALL API providers had machine readable OpenAPIs for all their services</span>, but I would want it to end here. You see, API providers are good (sometimes) at defining what their API does, but they often suck at telling you what is possible--which is why they are doing APIs. I have a lot of people who push back on me creating OpenAPIs for popular APIs, telling me that API providers should be the ones doing the hard work, otherwise it doesn't matter. I'm just not sold that this is the case, and there is an opportunity for evolving the definition&nbsp;of an API by external entities using OpenAPI.</p>
<p>To help me explore this idea, and push the boundaries of how I use OpenAPI in my API storytelling, I wanted to frame this in the context of the Amazon EC2 API, which allows me to deploy a single unit of compute into the cloud using an API, a pretty fundamental component of our digital worlds. To make any call against the Amazon EC2 I send all my calls to a single base URL:</p>
<p style="padding-left: 30px;"><code><em>ec2.amazonaws.com</em></code></p>
<p>With this API call I pass in the "action" I'd like to be taken:</p>
<p style="padding-left: 30px;"><code><em>?Action=RunInstances</em></code></p>
<p>Along with this base action parameter, I pass in a handful of other parameters to further define things:</p>
<p style="padding-left: 30px;"><code><em>&amp;ImageId=ami-60a54009&amp;MaxCount=1&amp;KeyName=my-key-pair&amp;Placement.AvailabilityZone=us-east-1d</em></code></p>
<p>Amazon has never been known for superior API design, but it gets the job done. With this single API call I can launch a server in the clouds. When I was first able to do this with APIs, is when the light really went on in my head regarding the potential of APIs. However, back to my story on expressing what an API does, as well as what is possible using OpenAPI. AWS has done an OK job at expressing what Amazon EC2 API does, however they suck at expressing what is possible. This is where API consumers like me step up with OpenAPI and provide some alternative representations of what is possible with the highly valuable API.</p>
<p>When I define the Amazon EC2 API using the OpenAPI specification I use the following:</p>
<p style="padding-left: 30px;"><code><em> swagger: '2.0'<br />info:<br />title: Amazon EC2<br />host: ec2.amazonaws.com<br />paths:<br />/:<br /><em>&nbsp; &nbsp; &nbsp;</em>get:<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;</em>summary: The Amazon EC2 service<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;o</em>perationId: ec2API<br /> <em>&nbsp; &nbsp; &nbsp;</em>parameters:<br /><em>&nbsp; &nbsp;&nbsp;</em><em>&nbsp; &nbsp; &nbsp;&nbsp;</em>- in: query<br /> <em>&nbsp; &nbsp; </em><em>&nbsp;</em><em>&nbsp; &nbsp; &nbsp; &nbsp;</em>name: action<br /> </em></code></p>
<p>The AWS API design pattern doesn't lend itself to reuse&nbsp;when it comes to documentation and storytelling, but I'm always looking for an opportunity to push the boundaries, and I'm able to better outline all available actions, as individual API paths by appending the action parameter to the path:</p>
<p style="padding-left: 30px;"><code><em> swagger: '2.0'<br />info:<br />title: Amazon EC2<br />host: ec2.amazonaws.com<br />paths:<br />/<em>?Action=RunInstances</em>/:<br /><em>&nbsp; &nbsp; &nbsp;</em>get:<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;</em>summary: Run a new Amazon EC2 instance<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;o</em>perationId: runInstance</em></code></p>
<p>Now I'm able to describe <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Operations.html">all 228 actions you can take with the single Amazon EC2 API path</a> as separate paths in any OpenAPI generated API documentation and tooling. I can give them unique summaries, descriptions, and operationId. OpenAPI allows me to describe what is possible with an API, going well beyond what the API provider was able to define. I've been using this approach to better quantify the surface area of APIs like Amazon, Flickr, and others who use this pattern for a while now, but as I was looking to update my work, I wanted to take this concept even further.</p>
<p>While appending query parameters to the path definition has allowed me to expand how I describe the surface area of an API using OpenAPI, I'd rather keep these parameters defined properly using the OpenAPI specification, and define an alternative way to make the path unique. To do this, I am exploring the usage of #bookmarks, to help make duplicate API paths more unqiue in the eyes of the schema validators, but invisible to the server side of things--something like this:</p>
<p style="padding-left: 30px;"><em>swagger: '2.0'<br />info:<br />title: Amazon EC2<br />host: ec2.amazonaws.com<br />paths:<br />/#RunInstance/:<br /><em>&nbsp; &nbsp; &nbsp;</em>get:<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;</em>summary: Run a new Amazon EC2 instance<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;o</em>perationId: runInstance<br /></em><em><em><span style="white-space: pre;"> </span>&nbsp; parameters:<br /></em></em><em><em><span style="white-space: pre;"> </span>&nbsp; &nbsp; &nbsp;- in: query<br /></em></em><em><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name: action<br /><em><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default: <em><em>RunInstances</em></em></em></em>&nbsp;</em></em></p>
<p>I am considering how we can further make the path unique, by predefining other parameters using default or enum:</p>
<p style="padding-left: 30px;"><em>swagger: '2.0'<br />info:<br />title: Amazon EC2<br />host: ec2.amazonaws.com<br />paths:<br />/#RunWebSiteInstance/:<br /><em>&nbsp; &nbsp; &nbsp;</em>get:<br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;</em>summary: Run a new Amazon EC2 website instance<br /><em><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;</em>description: The ability to launch a new website running on its own Amazon EC2 instance, from a predefined AWS AMI.&nbsp;</em><br /><em>&nbsp; &nbsp; &nbsp;</em><em>&nbsp; &nbsp; &nbsp;o</em>perationId: runWebServerInstance<br /></em><em><em><span> </span>&nbsp; parameters:<br /></em></em><em><em><span> </span>&nbsp; &nbsp; &nbsp;- in: query<br /></em></em><em><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name: action<br /><em><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default:&nbsp;<em><em>RunInstances</em></em></em></em></em></em>&nbsp;<br /><em><em>&nbsp; &nbsp; &nbsp;- in: query<br /></em></em><em><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name: <em>ImageId</em><br /><em><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default:&nbsp;<em><em><em>ami-60a54009</em></em></em></em></em></em></em>&nbsp;</p>
<p>I am still drawing&nbsp;in the lines of what the API provider has given me, but I'm now augmenting with a better summary and description of what is possible using OpenAPI, which can now be reflected in documentation and other tooling that is OpenAPI compliant. I can even prepopulate the default values, or available options using enum settings, tailoring to my team, company, or other specific needs. Taking an existing API definition beyond its provider interpretation of what it does, and getting to work on being more creative around what is possible.</p>
<p>Let me know how incoherent this is. I can't tell sometimes. Maybe I need more examples of this in action. I feel like it might be a big piece of the puzzle that has been missing for me regarding how we tell stories about what is possible with APIs. When it comes to API definitions, documentation, and discovery I feel like we are chained to a provider's definition of what is possible, when in reality this shouldn't be what drives the conversation. There should be definitions, documentation, and discovery documents created by API providers that help articulate what an API does, but more importantly, there should be a wealth of&nbsp;definitions, documentation, and discovery documents created by API consumers that help articulate what is possible.&nbsp;</p>