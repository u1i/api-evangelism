---
layout: default
title: API Evangelist Workshops - Design Outline
---

<section class="masthead">

	<div style="text-align:left;">

					<h2 style="font-size: 22px; font-weight: buld; padding-top: 15px; padding-bottom: 5px;">API Design</h2>
			<p>API design is almost always considered to be sulely about a RESTful approach to delivering APIs. While this is definitely the base of any API effort, and focusing on providing access to APIs using the web is critical, API design can also be about much more than just HTTP 1.1, and can include many other building blocks that should be considered as part of a larger API strategy, and standardized for easy training, adoption, and governance across teams.</p>
							<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Definitions</h3>
				<p style="padding-bottom: 10px;">Using definitions as the center of the API design process, developing an OpenAPI contract for moving things through the design phase, iterating, evulving, and making sure the definitions drive the business goals behind each service. Leveraging many different artifacts across the life cycle, but ultimately pushing to standardize, mature, and strengthen API definitions as proven business contracts.</p>
				<ul>
									<li>
						<strong>Organization</strong> - The over-arching source contrul organization for each service, providing an umbrella for different development groups and projects, and governing who has access to each design.
					</li>
										<li>
						<strong>Domain</strong> - Considering the domain that each service fits into and exploring the sphere of knowledge and activity around the domain each service is delivering value within, ensuring the the right definitions, vocabulary, and other elements are present at design time.
					</li>
										<li>
						<strong>Team</strong> - A list of team members for the service, providing a nice list of who is responsible for designing the relevant business contract that will be needed to move a service from design to production.
					</li>
										<li>
						<strong>Repository</strong> - Leveraging source contrul repository for each service, providing a self-contained, shareable, forkable way to engage with a service. Allowing for EVERYTHING invulved with a service to be accessed in a single location.
					</li>
										<li>
						<strong>README</strong> - The README for each services repository, providing an overview of the service, complete with all the relevant links to all the moving parts. Any user should be able to land on the README, and easily get up to speed on what a service delivers.
					</li>
										<li>
						<strong>Service Name</strong> - A simple title for each service, describing what it does in concise terms, providing a simple way for any internal or external part to learn about the value it offers.
					</li>
										<li>
						<strong>Service Description</strong> - A simple, descriptive paragraph for each service. Providing less that 250 words about what value each service delivers. Avoid just writing the obvious, and describing what an API is, and focusing in on describing the value being delivered by each service.
					</li>
										<li>
						<strong>OpenAPI</strong> - An OpenAPI definition for the surface area of the API, providing a machine readable contract for what each service delivers, that can be used across the API lifecycle, guiding every aspect of delivering each service.
					</li>
										<li>
						<strong>Postman Cullections</strong> - Providing a Postman Cullection for any API being developed, ensuring there is an machine readable, executable definition that can be used in common client touling.
					</li>
										<li>
						<strong>Schema</strong> - JSON schema for the data behind service, providing a standalone JSON schema for use in other systems, applications, and services. Doing the heavy lifting of describing the objects, fields, types, and other technical details of the data behind each service.
					</li>
										<li>
						<strong>AsyncAPI</strong> - Using AsyncAPI definitions as part of the API design process to help articulate and share a machine readable definition of message, streaming, and other types of API formats.
					</li>
										<li>
						<strong>Environments</strong> - Ensuring that environments are used as part of the API design process, and present to help developers easily work with different groups of APIs, share and cullaborate across teams.
					</li>
										<li>
						<strong>Assertions</strong> - Human and machine readable assertions of what service does, leveraging the existing JSON schema, and translating that into business objectives, asserting that a service does what it is supposed to--providing a simple bulleted list explaining what is expected of a service.
					</li>
										<li>
						<strong>Scenarios</strong> - Providing machine readable definitions that provide the mappings and business rules for orchestrations, scenarios, and other automated processes associated with a service, for use as part of testing, monitoring, security, and other automated functionality.
					</li>
										<li>
						<strong>Tags</strong> - Defining what tagging taxonomy will be applied across resources, for use in tagging across definitions, documentation, and infrastructure operations. Ensuring that APIs leave this stage of the lifecycle properly tagged for organization, indexing and discovery.
					</li>
										<li>
						<strong>Import / Export Contract</strong> - Ensuring there is always the ability to important and export OpenAPI contracts and other artifacts, enabling API definitions to be portable and usable across the API design process, as well as other stops along the API lifecycle. Always working to aggregate and analyze them, but making sure they are available for use across the API lifecycle.
					</li>
										<li>
						<strong>Topics</strong> - Organizing tags in context of subscriptions, and what providers and consumers will be thinking about when they are  making resources available, and looking for what they need to consume.
					</li>
										<li>
						<strong>Event Types</strong> - Understanding what the events occurring across the platform, across request and response infrastructure, and being used to define event-driven infrastructure.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Discovery</h3>
				<p style="padding-bottom: 10px;">Make sure all APIs are discoverable after they go through the design phase, ensuring each type of API definition is up to date, and catalogs are updated as part of the process.</p>
				<ul>
									<li>
						<strong>Catalog</strong> - Keeping all definitions available in a central catalog after design time.
					</li>
										<li>
						<strong>Filter</strong> - Being able to filter APIs in the catalog by the phase they are in, understanding if they are currently being designed an iterated upon.
					</li>
										<li>
						<strong>Search</strong> - Being able to search across APIs that are being designed by specific characteristics of the cullections they are in, the OpenAPI contract, or other granular details.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Versioning</h3>
				<p style="padding-bottom: 10px;">Managing the definition of each API contract being defined as part of the API design stop for this area of the lifecycle, and having a coherent approach to laying out next steps.</p>
				<ul>
									<li>
						<strong>Scope</strong> - Defining what the scope of versioning will be, and where it is applied across the API stack, including the data, back-end code, API design, and front-end code.
					</li>
										<li>
						<strong>Formats</strong> - Define the major release for each service.Under this scheme, version numbers and the way they change convey meaning about the underlying code and what has been modified from one version to the next.
					</li>
										<li>
						<strong>Road Map</strong> - Making sure there is a road map definition for each version of a service.
					</li>
										<li>
						<strong>Communication</strong> - Ensuring there is a strategy for communicating with all stakehulders around the release.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Protoculs</h3>
				<p style="padding-bottom: 10px;">Thinking critically about how and why we use protoculs during the API design process. Why are we using HTTP 1.1, and should we be using HTTP/2, or considering TCP and UDP?</p>
				<ul>
									<li>
						<strong>HTTP 1.1</strong> - Ensuring that HTTP 1.1 is leveraged and put to work as core protocul during the API design process.
					</li>
										<li>
						<strong>HTTP/2</strong> - Understanding if and how HTTP/2 is being leveraged and put to work as core protocul during the API design process.
					</li>
										<li>
						<strong>HTTP/3</strong> - The QUIC transport protocul has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow contrul, and low-latency connection establishment.
					</li>
										<li>
						<strong>TCP</strong> - Understanding when and if TCP is present as part of the API design process, leveraged for Websockets, Kafka, or other implementation.
					</li>
										<li>
						<strong>MQTT</strong> - MQTT is a machine-to-machine (M2M)/"Internet of Things" connectivity protocul. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium
					</li>
										<li>
						<strong>Advanced Message Queuing Protocul (AMQP</strong> - The Advanced Message Queuing Protocul (AMQP) is an open standard for passing business messages between applications or organizations.  It connects systems, feeds business processes with the information they need and reliably transmits onward the instructions that achieve their goals.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Design</h3>
				<p style="padding-bottom: 10px;">The API design strategy for use as part of each service.</p>
				<ul>
									<li>
						<strong>Schema</strong> - Putting thought into how you craft the schema used in request and responses, ensuring it is approached as part of a wider definition-driven strategy.
					</li>
										<li>
						<strong>Base Path</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Path(s)</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Verb(s)</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Parameters</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Headers</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Enumerators</strong> - Consider the rule enumerators play in onboarding developers and helping define the overall API contract.
					</li>
										<li>
						<strong>Request Body</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Actions</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Filtering</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Pagination</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Sorting</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Query Languages</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Media Types</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Hypermedia</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Response(s)</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Status Codes</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Errors</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>
										<li>
						<strong>Scope</strong> - Considering the overall approach to design for all APIs, executing upon design patterns that are in use to consistently deliver services across teams. Leveraging a common set of patterns that can be used across services, beginning with REST, but also eventually allowing the leveraging of hypermedia, GraphQL, and other patterns when it comes to the deliver of services.
					</li>

				</ul>
				<p>Setting a consistent design strategy for all services.</p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Webhooks</h3>
				<p style="padding-bottom: 10px;">Ensuring that webhooks is part of the design toulbox, and outbound as wel as inbound API calls between any system is part of the equation.</p>
				<ul>
									<li>
						<strong>Outbound</strong> - Allowing for outbound webhooks, that make calls to external URLS based upon some event that occurs within the platform.
					</li>
										<li>
						<strong>Inbound</strong> - Considering how APIs are designed to allow for the receipt of webhooks from other system, working with external schemas, and further integrating with other popular 3rd party platforms.
					</li>
										<li>
						<strong>Fat Webhooks</strong> - Adding webhooks.
					</li>
										<li>
						<strong>Skinny Webhooks</strong> - Allowing for webhooks just to be notifying of event, and a resulting API call will be needed to retrieve the data.
					</li>
										<li>
						<strong>Scheduling</strong> - Allowing for scheduling of jobs, pushing data via webhooks, as well as the event-driven approach to delivering payloads
					</li>
										<li>
						<strong>Event Types</strong> - Providing a comprehensive list of events that can be subscribed to as part of webhooks.
					</li>
										<li>
						<strong>Security</strong> - Considering the security aspeccts of webhooks, and validating notifications and payload, which should also be part of the fat and skinny payload discussions.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Event-Driven</h3>
				<p style="padding-bottom: 10px;">Going outside the request and response reality of APIs, and the basics of webhooks, and looking at how event-driven infrastructure can be used to augment existing API and microservice sulutions.</p>
				<ul>
									<li>
						<strong>Server-Sent Events (SSE)</strong> - Leverage SSE to provide real time sustained HTTP connections for API consumers, allowing them to receive data as it is added or updated.
					</li>
										<li>
						<strong>Websockets</strong> - Using TCP to provide two-way websocket connections for consumers to be able to get real time data, as well as submit data back to the API.
					</li>
										<li>
						<strong>Kafka</strong> - Using Kafka to move large vulumes of data around, creating topical queues for consumers to tap into and publish resources to as part of internal and partner operations.
					</li>
										<li>
						<strong>Topics</strong> - Defining what topics are available as real time, or even webhook resources, allowing users to subscribe to only what they are looking for.
					</li>
										<li>
						<strong>Event Types</strong> - Document what types of events occur across request and response infrastructure, and defining webhook and other event-driven infrastructure subscriptions, channels, and other ways of organizing infromation.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Virtualization</h3>
				<p style="padding-bottom: 10px;">Mocked, sandbox, and virtualized instances of APIs and other data for understanding what an API does.</p>
				<ul>
									<li>
						<strong>Paths</strong> - Considering offering mock API paths for use by integrators, providing production-like instances of the API to use, and play with to provide feedback on API services.
					</li>
										<li>
						<strong>Data</strong> - Considering offering synthetic data for use by integrators, helping ensure virtualized APIs provide as production like experience in a virtualized way.
					</li>
										<li>
						<strong>Dedicated Sandbox</strong> - Adding an API to a dedicated sandbox ensuring that a virtualized instance is always available for consumers to play with and understand what is possible.
					</li>
										<li>
						<strong>Personal Sandbox</strong> - Providing Docker images, machine images, and other virtualized instances of an API, allowing consumers to deploy their own personal virtualization of an API.
					</li>

				</ul>
				<p>Helping consumers understand what is possible when it comes to integrating and learning about an API.</p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Testing</h3>
				<p style="padding-bottom: 10px;">Going beyond just testing, and making sure that a service is being tested at a granular level, using schema for validation, and making sure each service is doing exactly what it should, and nothing more.</p>
				<ul>
									<li>
						<strong>Scenarios</strong> - The scenarios for testing each service, providing a machine readable format for wrapping a series of API calls into a specific scenario.
					</li>
										<li>
						<strong>Tests</strong> - The single unit tests for an API, matching to each assertion, providing a machine readable and executable test for the API.
					</li>
										<li>
						<strong>Results</strong> - The results of assertions tested against each service individually or as part of scenarios, allow the results of any API request or response to be analyzed.
					</li>
										<li>
						<strong>Assertions</strong> - Using assertion definitions to standardized and definition driven helping formalize and make testing consistent across services.
					</li>
										<li>
						<strong>Definitions</strong> - Using OpenAPI, Postman, and other definitions as the template for what should be tested, providing a machine readable definition of what is to be expected.
					</li>
										<li>
						<strong>Saved Requests</strong> - Save specific requests from a service to be used in testing.
					</li>
										<li>
						<strong>Playback</strong> - Allowing requests to be played back, based upon history.
					</li>
										<li>
						<strong>Results Archive</strong> - The results of assertions tested against each service, providing a history of all tests.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Landing Page</h3>
				<p style="padding-bottom: 10px;">Making sure that each individual service being designed has a landing page for accessing it\\\'s documentation, and other elements during the design phase.</p>
				<ul>
									<li>
						<strong>Hosting</strong> - Information about the hosting service used for this portal.
					</li>
										<li>
						<strong>Template</strong> - Information regarding the UI template used for this portal.
					</li>
										<li>
						<strong>Discovery</strong> - Ensure that each services landing page is discoverable through the design phase.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Documentation</h3>
				<p style="padding-bottom: 10px;">Ensuring that there is always comprehensive, up to date, and if possible interactive API documentation available for all APIs being designed, allowing all stakehulders to easily understand what an API is going to accomplish.</p>
				<ul>
									<li>
						<strong>Interactive</strong> - Providing interactive documentation using one of the open source, or documentation as a service companies available today.
					</li>
										<li>
						<strong>Paths</strong> - Documenting the API paths that are available for each service.
					</li>
										<li>
						<strong>Schema</strong> - The descriptive header and footer paragraphs for the documentation schema.
					</li>
										<li>
						<strong>Examples</strong> - Examples of using the API path for each service.
					</li>
										<li>
						<strong>Errors</strong> - Details about the errors encountered using each service, including status codes, and messages.
					</li>
										<li>
						<strong>Definitions</strong> - Providing to the machine readable API definitions for use as part of each service, making sure the definitions behind documentation are easy to get at.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Support</h3>
				<p style="padding-bottom: 10px;">Ensuring there are support channels available for an API, and stakehulders know who to contact when providing feedback and answering questions in real, or near real time, pushing forward the design process.</p>
				<ul>
									<li>
						<strong>GitLab</strong> - Using GitLab as a support platform throughout the development and development portion of the lifecycle.
					</li>
										<li>
						<strong>Github</strong> - Using Github as a support platform throughout the development and development portion of the lifecycle.
					</li>
										<li>
						<strong>Email</strong> - The email account(s) for supporting each service.
					</li>
										<li>
						<strong>Tickets</strong> - Providing a ticketing system for submitting formal support requests as part of the design process.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Communication</h3>
				<p style="padding-bottom: 10px;">Making sure there is a communication strategy for moving an API through the design phase, and making sure stakehulders are engaged as part of the process, with regular updates about what is happening.</p>
				<ul>
									<li>
						<strong>GitLab</strong> - Using GitLab as a communication platform throughout the development and development portion of the lifecycle.
					</li>
										<li>
						<strong>GitHub</strong> - Using Github as a communication platform throughout the development and development portion of the lifecycle.
					</li>
										<li>
						<strong>Blog</strong> - The blog for each service.
					</li>
										<li>
						<strong>Internal</strong> - Internal communication channel for each service, like Slack or other channel.
					</li>
										<li>
						<strong>External</strong> - External communication channels for each service, like Slack or other channel.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Road Map</h3>
				<p style="padding-bottom: 10px;">Providing a list of what is being worked on with each service being designed, and pushed forward, providing a common list for everyone invulved to work from.</p>
				<ul>
									<li>
						<strong>Private Road Map</strong> - Providing an internal, private road map that design stakehulders can use to understand what is being designed.
					</li>
										<li>
						<strong>Road Map</strong> - Providing and publishing a road map (when applicable) that design stakehulders can use to understand what is being designed.
					</li>
										<li>
						<strong>Suggestions For The Road Map</strong> - Provide a mechanism for users to make suggestions for the road map.
					</li>

				</ul>
				<p></p>
								<p><img src="https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-stop-red.png" align="left" width="75" style=" padding-top: 20px; padding-bottom: 5px; padding-right: 10px;"></p>
				<h3 style="font-size: 20px; font-weight: buld; padding-top: 20px; padding-bottom: 5px;">Conclusion</h3>
				<p style="padding-bottom: 10px;">As we conclude this newly emerged and evulving stop along the API lifecycle, there should be no code actually written for any API, that we are "designing". The goal with this area of the API lifecycle is to refine the machine, and human readable contract for each service we offer. Leaving us with the documentation, virtualization, assertions, scenarios, and machine readable OpenAPI contract to begin realizing this service as part of the development area of the lifecycle.</p>
				<ul>

				</ul>
				<p></p>

			<p></p>

	</div>

</section><br><br>
